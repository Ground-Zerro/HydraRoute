# Принцип работы HRneo - Архитектура и производительность

## 1. Общий принцип работы системы

### Архитектура перехвата DNS-трафика

Система работает по следующей схеме:

```
Клиент → DNS-запрос (порт 53) → NFLOG перехватывает → Программа анализирует
                                                              ↓
                                                    Сохраняет txID в кеше
                                                              ↓
DNS-ответ → NFLOG перехватывает → Программа находит txID → Добавляет IP в ipset
```

### Ключевые этапы обработки

#### Этап 1: DNS-запрос (processDNSQuery)
- Перехватывается запрос к домену
- Проверяется совпадение с watchlist
- Transaction ID сохраняется в кеше: `dnsCache.Set(txID, ipsetName)`
- **⚡ DNS-запрос проходит дальше БЕЗ ЗАДЕРЖКИ**

#### Этап 2: DNS-ответ (processDNSAnswer)
- Перехватывается ответ с IP-адресами
- По transaction ID находится соответствующий ipset
- IP-адреса добавляются в ipset
- **⚡ DNS-ответ тоже проходит БЕЗ ЗАДЕРЖКИ**

---

## 2. Разрыв соединений (conntrack) - КРИТИЧНО НЕОБХОДИМ

### Код разрыва соединений

```go
if m.reconnect && len(allIPs) > 0 {
    for _, ip := range allIPs {
        clearConntrackFast(ip)
    }
}
```

### Почему это критически важно?

Рассмотрим временную шкалу событий:

```
t=0ms:  Клиент → SYN → google.com (173.194.73.100)
t=5ms:  google.com → SYN-ACK → Клиент
t=10ms: Установлено соединение (ESTABLISHED в conntrack)
        ❌ iptables правила НЕ применяются (соединение уже установлено)
        
t=50ms: DNS-ответ перехвачен → IP добавлен в ipset
        ❌ НО! Соединение уже в conntrack с меткой "ESTABLISHED"
        ❌ Новые правила iptables НЕ сработают!
```

### Решение через clearConntrack

```go
clearConntrackFast(ip)  // Удаляет запись из conntrack
// ✅ Теперь следующие пакеты пройдут через NEW state
// ✅ и iptables правила с ipset сработают
```

---

## 3. Задержки для клиента - ОТСУТСТВУЮТ

### NFLOG работает асинхронно

```go
// В nflog_monitor.go
hook := func(attrs nflog.Attribute) int {
    // Этот callback выполняется В ОТДЕЛЬНОЙ ГОРУТИНЕ
    // Пакет УЖЕ прошел дальше по сети
    
    if udp.SrcPort == 53 {
        m.wg.Add(1)
        m.semaphore <- struct{}{}
        
        go func(pkt gopacket.Packet) {  // ← Асинхронная обработка
            defer m.wg.Done()
            defer func() { <-m.semaphore }()
            m.processDNSAnswer(pkt)
        }(packet)
    }
    
    return 0  // ← Возврат немедленно, пакет не блокируется
}
```

### Путь DNS-пакета

```
DNS-запрос → iptables NFLOG (копирует пакет) → Пакет идет дальше
                    ↓
            Копия в userspace
                    ↓
            Программа анализирует
            (АСИНХРОННО, не блокирует оригинал)
```

**Ключевой момент:** NFLOG создает **копию** пакета для анализа, а оригинальный пакет продолжает свой путь без задержек.

---

## 4. Временная диаграмма реальной работы

### Полный цикл обработки запроса

```
t=0ms:   Клиент отправляет DNS-запрос "youtube.com"
         └→ NFLOG копирует пакет → программа анализирует (фоново)
         └→ Оригинал идет к DNS-серверу БЕЗ ЗАДЕРЖКИ

t=20ms:  DNS-сервер отвечает с IP: 142.251.1.136
         └→ NFLOG копирует ответ → программа обрабатывает (фоново)
         └→ Ответ приходит к клиенту БЕЗ ЗАДЕРЖКИ
         
t=21ms:  Клиент получил DNS-ответ (задержка = 0ms от программы)
         
t=22ms:  Программа добавила IP в ipset (фоново)
         Программа удалила conntrack для 142.251.1.136
         
t=25ms:  Клиент начинает TCP-соединение с 142.251.1.136
         iptables видит: "это NEW соединение" (т.к. conntrack очищен)
         iptables проверяет: IP в ipset "Disable"
         iptables применяет правило CONNMARK (маркировка трафика)
```

---

## 5. Проблемы и Race Conditions

### Потенциальный плохой сценарий

```
❌ Плохой сценарий (race condition):

t=0ms:   DNS-запрос → NFLOG
t=20ms:  DNS-ответ получен клиентом
t=21ms:  Клиент СРАЗУ открывает TCP к IP (быстрый браузер)
t=22ms:  TCP SYN отправлен
t=23ms:  TCP SYN-ACK получен → conntrack создает ESTABLISHED
t=25ms:  Программа ТОЛЬКО СЕЙЧАС добавила IP в ipset ← ⚠️ ПОЗДНО!
```

### Почему clearConntrack ОБЯЗАТЕЛЕН

Даже если соединение установилось **ДО** добавления IP в ipset, `clearConntrack` разорвет его, и при повторном подключении правила уже сработают.

**Решение:**
- ✅ Conntrack очищается сразу после добавления IP в ipset
- ✅ При следующем пакете соединение будет в состоянии NEW
- ✅ iptables правила применятся корректно

---

## 6. Оптимизация кода

Текущая реализация включает следующие оптимизации:

| Оптимизация | Описание | Преимущество |
|-------------|----------|--------------|
| ✅ **Асинхронная обработка** | DNS-ответы обрабатываются в отдельных goroutines | Нулевая задержка для клиента |
| ✅ **Semaphore (MaxConcurrent=100)** | Ограничение одновременных горутин | Защита от перегрузки памяти |
| ✅ **Batch-добавление** | `AddIPBatch` добавляет несколько IP за раз | Меньше syscalls к ядру |
| ✅ **Кеширование** | Проверка перед добавлением в ipset | Избежание дублирования |
| ✅ **Fast conntrack clearing** | `clearConntrackFast` без проверок | Максимальная скорость |
| ✅ **Netlink вместо ipset CLI** | Прямое взаимодействие с ядром | В 10-100 раз быстрее |

### Пример оптимизации через Netlink

```go
// Старый подход (медленно):
exec.Command("ipset", "add", setName, ip1).Run()
exec.Command("ipset", "add", setName, ip2).Run()
exec.Command("ipset", "add", setName, ip3).Run()
// 3 форка процесса + 3 парсинга CLI

// Новый подход (быстро):
nlManager.AddIPBatch(setName, []string{ip1, ip2, ip3})
// 3 прямых netlink вызова к ядру, без fork
```

---

## 7. Итоговая таблица

| Вопрос | Ответ |
|--------|-------|
| **Нужен ли clearConntrack?** | **ДА, критично необходим** для работы с уже установленными соединениями |
| **DNS вызовы добавляют задержки?** | **НЕТ, NFLOG работает асинхронно**, нулевая задержка для клиента |
| **Когда применяются правила?** | При **NEW** соединениях, поэтому conntrack должен быть очищен |
| **Влияет ли на скорость интернета?** | **НЕТ**, вся обработка в фоне, пакеты не блокируются |
| **Может ли пропустить IP?** | Теоретически да (race condition), но clearConntrack минимизирует риск |

---

## 8. Выводы

### Принцип работы

Система работает как **прозрачный перехватчик DNS-трафика**:
- Не замедляет DNS-запросы
- Не блокирует сетевые пакеты
- Работает полностью в фоновом режиме

### Критические компоненты

1. **NFLOG** - асинхронное копирование пакетов
2. **Netlink** - быстрое добавление IP в ipset
3. **clearConntrack** - принудительный разрыв существующих соединений
4. **iptables mangle CONNMARK** - маркировка трафика для policy routing

### Производительность

- **Задержка DNS:** 0 мс (асинхронная обработка)
- **Время добавления IP:** ~1-2 мс (через netlink)
- **Очистка conntrack:** ~0.5 мс
- **Итого:** ~3-5 мс от DNS-ответа до применения правил

**Вывод:** Система высокопроизводительна и прозрачна для конечного пользователя.
